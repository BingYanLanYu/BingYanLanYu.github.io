[{"title":"Hello World","url":"/2025/10/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["测试"],"tags":["欢迎"]},{"title":"Docker 安装 Oracle 19c","url":"/2025/10/31/7.%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/Docker/Docker%20%E5%AE%89%E8%A3%85%20Oracle%2019/","content":"一、环境说明\n虚拟机：VMware Workstation Pro 17\n\n系统：Ubuntu 24.04.2 服务器版\n\n内存：6G\n处理器：2\n硬盘：30G\n\n\nSSH：FinalShell 4.5.12\n\nDocker 版本：Docker 28.4.0\n\n数据库：Oracle 19c\n\n数据库管理工具：DBeaver\n\n\n本次安装的版本是 Oracle 19c，属于长期支持版本，是当前部署最广泛、最成熟稳定的版本，适用于绝大多数核心生产系统。考虑到 Oracle 19c 的大小，一定要注意磁盘容量，不然拉取镜像可能导致失败。\n当前登录用户已加入 docker 组，所以在执行 Docker 命令时无需添加 sudo。\n二、安装2.1 拉取镜像拉取镜像可以从 Oracle 官网，也可以从第三方。\n考虑到下载速度，此次是从阿里云下载。\ndocker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c\n\n通过 docker images 命令，可以看到下载的镜像。\n \n2.2 创建并授权本地目录为了持久化保存数据库文件（避免容器删除后数据丢失），需要创建一个目录并赋予相应权限：\nsudo mkdir -p /docker/oracle19c/oradata  # 创建目录sudo chmod 777 /docker/oracle19c/oradata  # 授予读写执行权限\n\n\n\n2.3 运行容器使用 docker run 命令运行容器。\ndocker run -d \\  --name oracle19c \\  --restart=unless-stopped \\  -p 1521:1521 \\  -p 5500:5500 \\  -e ORACLE_SID=ORCLCDB \\  -e ORACLE_PDB=ORCLPDB \\  -e ORACLE_PWD=oracle \\  -e ORACLE_CHARACTERSET=AL32UTF8 \\  -v /docker/oracle19c/oradata:/opt/oracle/oradata \\  registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c\n\n命令解析：\n\ndocker run：Docker 的核心命令，用于从镜像创建并启动一个新容器。\n-d：--detach 的简写，表示在后台运行容器，并返回容器ID。这样终端不会被容器的输出日志所占用。\n--name oracle19c：为容器指定一个易于识别的名称 oracle19c，方便后续的管理操作（如启动、停止、查看日志），而不需要使用冗长的容器ID。\n--restart=unless-stopped：这是解决“开机自启动”问题的关键参数。 它定义了容器的重启策略。\nunless-stopped 表示：无论容器以何种原因退出（包括正常退出），Docker 守护进程都会自动重启它，除非容器是被你明确地手动停止的（例如使用了 docker stop oracle19c 命令）。\n这个策略确保了即使宿主机重启，Docker 服务起来后也会自动把你的 Oracle 容器拉起来。\n\n\n-p 1521:1521：端口映射，这是连接数据库的关键。\n格式：-p &lt;宿主机端口&gt;:&lt;容器内端口&gt;\n作用：将容器内部的 1521 端口（Oracle 数据库默认的监听端口）映射到宿主机的 1521 端口。\n结果：外部客户端（如 SQL Developer、JDBC 程序）可以通过访问 宿主机IP:1521 来连接到容器内的 Oracle 数据库。\n\n\n-p 5500:5500：同样是端口映射。\n作用：将容器内部的 5500 端口（Oracle EM Express 的控制台端口）映射到宿主机的 5500 端口。\n结果：你可以通过浏览器访问 https://宿主机IP:5500/em 来打开 Oracle Enterprise Manager Database Express 的 Web 管理界面。\n\n\n-e ORACLE_SID=ORCLCDB：设置环境变量，用于定义 Oracle 的系统标识符（System ID），即数据库实例名。这里设置为 ORCLCDB。\n-e ORACLE_PDB=ORCLPDB：设置环境变量，用于定义可插拔数据库（Pluggable Database, PDB）的名称。Oracle 19c 采用多租户架构，CDB（Container Database）是容器，里面可以包含多个 PDB。这里设置为 ORCLPDB。\n-e ORACLE_PWD=oracle：设置环境变量，定义数据库特权用户（如 SYS, SYSTEM）的初始密码。请注意：为了安全，在生产环境中务必使用强密码！\n-e ORACLE_CHARACTERSET=AL32UTF8：设置环境变量，定义数据库的字符集。AL32UTF8 是 Unicode 字符集，能够完美支持中文和各种国际字符，避免出现乱码问题。\n-v /docker/oracle19c/oradata:/opt/oracle/oradata：数据卷挂载，这是保证数据持久化的关键，非常重要！\n格式：-v &lt;宿主机目录&gt;:&lt;容器内目录&gt;\n作用：将宿主机上的目录 /docker/oracle19c/oradata 挂载到容器内的 /opt/oracle/oradata 目录。\n结果：容器内数据库生成的所有数据文件（控制文件、数据文件、重做日志等）都会实际存储在宿主机的目录中。即使容器被删除，数据也不会丢失。下次启动新容器时只要挂载同一个目录，数据就能恢复。\n\n\nregistry...:19c：指定用于创建容器的镜像名称和标签（Tag）。这里是从阿里云镜像仓库拉取的 Oracle 19c 镜像。\n\n执行这个命令，在后台启动一个名为 oracle19c 的容器，它运行着一个开机自启动的 Oracle 19c 数据库实例。该实例的 SID 是 ORCLCDB，内含一个名为 ORCLPDB 的可插拔数据库，使用 UTF-8 字符集，并将所有数据持久化存储在宿主机的 /docker/oracle19c/oradata 目录下。外部可以通过主机的 1521 端口连接数据库，也可以通过 5500 端口访问 Web 管理界面。\n成功运行后，你就可以使用连接字符串 宿主机IP:1521/ORCLPDB 和用户名 system &#x2F; 密码 oracle 来连接这个数据库了。\n2.4 查看安装过程执行运行命令后，可以马上执行日志查看命令。创建实例的过程会比较长，请耐心等待。\ndocker logs -ft oracle19c\n\n命令解析：\n\n\n\n命令部分\n含义与作用\n补充说明\n\n\n\ndocker logs\nDocker 查看容器日志的基础命令。\n用于获取容器的标准输出（stdout）和标准错误（stderr）。\n\n\n-f\n--follow 的简写。保持输出日志，即实时显示容器产生的新日志，直到手动中断（如按 Ctrl+C）。\n类似于 tail -f 命令的效果。这在观察数据库初始化等长时间进程时非常有用。\n\n\n-t\n--timestamps 的简写。显示时间戳，即在每一行日志前加上日志产生的时间（通常是 UTC 时间）。\n方便你定位事件发生的具体时间，对排查时序相关问题有帮助。\n\n\noracle19c\n容器的名称或 ID。这里指定要查看的是名为 oracle19c 的容器。\n容器名称通常在 docker run 启动容器时通过 --name 参数指定（例如 --name oracle19c）。\n\n\n当日志出现 DATABASE IS READY TO USE! 则表明安装成功。\n\n当然也可以执行 docker ps 命令查看当前正在运行的容器。\n \n三、连接3.1 进入容器内连接3.1.1 进入容器docker exec -it oracle19c /bin/bash\n\n命令解析：\n\n\n\n命令部分\n含义与作用\n\n\n\ndocker exec\nDocker 命令，用于在正在运行的容器内部执行一条命令。\n\n\n-i\n--interactive 的简写。保持标准输入（stdin）打开，允许你与容器内的命令进行交互（比如输入命令）。\n\n\n-t\n--tty 的简写。分配一个伪终端（pseudo-TTY），让你获得一个格式良好的、类似 SSH 的交互式 shell 体验。\n\n\n-it\n通常组合使用，为容器内的进程提供一个交互式的终端。\n\n\noracle19c\n目标容器的名称（由 docker run --name oracle19c 指定）。\n\n\n/bin/bash\n要在容器内部执行的命令，这里是启动 Bash shell。\n\n\n这条命令会打开一个终端，让你可以像通过 SSH 连接到一台独立服务器一样，在名为 oracle19c 的容器内部执行各种 Linux 命令（如 ls, cd, ps 等）。结果如下：\n \n3.1.2 连接数据库sqlplus / as sysdba\n\n命令解析：\n\n\n\n命令部分\n含义与作用\n\n\n\nsqlplus\nOracle 提供的命令行数据库管理工具，是与 Oracle 数据库交互的主要界面。\n\n\n/\n一种特殊的身份验证方式，称为 “操作系统认证”。它告诉 SQL*Plus：“使用当前登录到操作系统的用户身份来验证我”。\n\n\nas sysdba\n一个特殊的权限角色，全称是 SYStem DataBase Administrator。这是 Oracle 数据库中最高级别的管理权限。\n\n\n/ as sysdba\n组合起来的意思是：“请使用操作系统认证的方式，将我以 SYSDBA 的超级管理员身份登录到数据库”。\n\n\n在容器内执行该命令，将以最高权限连接到 Oracle 数据库。结果如下：\n \n3.1.3 执行一条语句show pdbs;\n\n这个命令用于查看当前数据库实例中所有可插拔数据库（Pluggable Databases, PDBs）的摘要信息。\n \n3.1.4 退出如果要退回到主机，可以通过 exit 命令：\n\n输入 exit 退出 SQL*Plus，回到容器内的 Bash。\n再输入一次 exit 退出容器，回到宿主机。\n\n3.2 进入控制台3.2.1 EM Express 地址Oracle Enterprise Manager Database Express（EM Express）是一个基于 Web 的轻量级数据库管理工具，提供了对数据库性能、配置、空间使用情况和安全性的基本监控和管理功能。\nhttps://&lt;hostname&gt;:&lt;port&gt;/em\n\n\n&lt;hostname&gt;：数据库服务器的主机名或 IP 地址。\n&lt;port&gt;：设置的 EM Express 端口（如 5500）。\n\nEM Express 必须使用 HTTPS 协议。首次访问时，浏览器可能会警告你的连接不是专用连接，继续访问即可。\n\n3.2.2 登录\nUsername：sys\nPassword：oracle\nContainer Name：ORCLPDB\n\nUsername 应该是具有SYSDBA或SYSOPER权限的账户，比如 SYS、SYSTEM。Password 和 Container Name 则是 docker run 命令中配置的内容。\n\n3.3 DBeaver 连接如果第一次使用 DBeaver 连接 Oracle 数据库，会需要下载对应驱动。不过，这个不需要你手动下载，一般会自动下载。\n \n","categories":["云原生与分布式架构"],"tags":["Docker","安装","Oracle 19c"]},{"title":"Ubuntu 24.04 安装 Docker","url":"/2025/10/31/7.%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/Docker/Ubuntu%2024.04%20%E5%AE%89%E8%A3%85%20Docker/","content":"一、环境说明虚拟机：VMware Workstation Pro 17\n系统：Ubuntu 24.04.2 服务器版\nSSH：FinalShell 4.5.12\n当前系统状态为刚完成安装，进行一些基础配置。\n当前登录用户为普通用户，因此所有命令都需要添加 sudo 命令来临时获得 root 权限。至于需要输入密码的问题，通过修改 /etc/sudoers 来解决。\n因为当前使用的是 VMware，考虑到安装过程可能出现意外，建议对当前系统环境拍摄快照，以便后期恢复。\n拍摄快照：VMware 选中当前计算机 - 右键选中「快照」 - 「拍摄快照」。\n官方安装文档：在 Ubuntu 上安装 Docker Engine\n二、安装 Docker2.1 验证当前系统是否安装 Dockerdocker -v\n\n \n可以看到当前系统并没有安装 Docker 引擎，同时系统给出了安装语句，但我们通常建议使用 Docker 官方源安装最新版本，而不是使用 Ubuntu 自带的 docker.io（可能较旧）。\n2.2 更新软件包索引sudo apt update\n\n在安装软件前推荐先执行此命令，用于刷新本地的软件包索引，这样可以确保后续安装或升级时获取的是最新版本信息。\n2.3 安装依赖包sudo apt install -y ca-certificates curl\n\n\nca-certificates：允许系统信任 HTTPS 证书，用于安全地访问网络源。\ncurl：命令行工具，用于从网络下载文件（如 Docker 的 GPG 密钥）。\n\n2.4 创建用于存储 GPG 密钥的目录sudo install -m 0755 -d /etc/apt/keyrings\n\n\ninstall：一个用于复制文件和创建目录的命令，比 mkdir 和 chmod 的组合更简洁。\n-m 0755：设置目录的权限为 0755（所有者可读、写、执行，其他用户可读和执行）。这是存储密钥目录的标准权限。\n-d：指定要创建的是目录而不是文件。\n/etc/apt/keyrings：APT 包管理器推荐的用于存储第三方软件仓库密钥的目录。\n\n2.5 下载 GPG 密钥下载 Docker 官方的 GPG 密钥，并将其保存到上一步创建的目录中。\nGPG 密钥用于验证 Docker 软件包的“身份”和“完整性”，确保你下载的 Docker 软件包来自可信的源头，并且在传输过程中没有被任何人篡改或植入恶意代码。\n在官方中使用下载的地址是：https://download.docker.com/linux/ubuntu/gpg，此处改为阿里云镜像地址，但下载下来的还是官方的 GPG 密钥。\nsudo curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\n\n\n-f 或 --fail：让 curl 在服务器错误时静默失败（不输出 HTML 错误页面）。\n-s 或 --silent：静默模式，不显示进度条或错误信息。\n-S 或 --show-error：与 -s 一起使用时，如果失败会显示错误信息。\n-L 或 --location：如果请求的页面发生了重定向，则自动跟随重定向。\n-o /etc/apt/keyrings/docker.asc：将下载的内容输出到指定文件。文件扩展名 .asc 表明这是一个 ASCII 格式的 GPG 密钥。\n\n2.6 更改密钥文件的权限为所有用户添加可读的权限，这样所有用户下载时都可以通过密钥进行验证。\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\nchmod a+r：a 代表所有用户 (all)，+r 代表添加读取 (read) 权限。\n\n2.7 添加 Docker 的软件源将 Docker 的官方软件源添加到 Ubuntu 24.04 的软件源列表，apt install 时用于获取官方源提供 Docker CE 的所有组件：docker-ce, docker-ce-cli, containerd.io, docker-buildx-plugin, docker-compose-plugin 等。\n即告诉 Ubuntu 系统，以后获取 Docker 软件包不要从 Ubuntu 自己的仓库找，而要从 Docker 官方的这个特定地址获取，并且使用指定的 GPG 密钥来验证这些软件包的真伪。\n此处地址为官方地址的阿里云镜像地址，Docker 官方地址为：https://download.docker.com/linux/ubuntu。\necho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] http://mirrors.aliyun.com/docker-ce/linux/ubuntu \\  $(. /etc/os-release &amp;&amp; echo &quot;$&#123;UBUNTU_CODENAME:-$VERSION_CODENAME&#125;&quot;) stable&quot; | \\  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n\necho &quot;deb [arch=...] ...&quot;：\n用于生成一个标准的 Debian&#x2F;Ubuntu 软件源条目（sources.list entry）。\n\n\n[arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]：\narch=$(dpkg --print-architecture)：这是一个命令替换。它会先执行 dpkg --print-architecture 命令（该命令会输出您系统的架构，如 amd64 或 arm64），然后用输出结果替换这部分内容。这确保了软件源地址与您的系统架构匹配。\nsigned-by=/etc/apt/keyrings/docker.asc：极其重要。它明确指定了用于验证此软件源中所有软件包的 GPG 密钥的路径。这是确保软件包来自 Docker 官方而非恶意镜像的安全关键步骤。\n\n\nhttp://mirrors.aliyun.com/docker-ce/linux/ubuntu：\nDocker 官方软件源的阿里云镜像地址。\n\n\n$(. /etc/os-release &amp;&amp; echo &quot;${UBUNTU_CODENAME:-$VERSION_CODENAME}&quot;)：\n这是另一个命令替换和参数扩展的巧妙结合。\n. /etc/os-release：这会执行（source）一个系统文件，该文件包含当前 Ubuntu 版本的详细信息（如 VERSION_ID=&quot;24.04&quot;, VERSION_CODENAME=noble, UBUNTU_CODENAME=noble）。\n&amp;&amp; echo &quot;${UBUNTU_CODENAME:-$VERSION_CODENAME}&quot;：如果前一个命令成功，则执行 echo。${UBUNTU_CODENAME:-$VERSION_CODENAME} 是一个参数扩展，意思是“如果 UBUNTU_CODENAME 变量存在且不为空，则使用它的值；否则，使用 VERSION_CODENAME 的值”。\n最终，这部分会被替换为您的 Ubuntu 系统代号，例如 jammy (22.04), noble (24.04) 等。这确保了您添加的软件源与您的系统版本完全匹配。\n\n\nstable：\n指定要使用 Docker 的稳定版（stable）发布通道。而不是测试版（test）或夜间构建版（nightly）。\n\n\n| sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null：\n|：管道符，将 echo 命令的输出传递给 tee 命令。\ntee：一个同时输出到屏幕和文件的命令。这里与 sudo 一起使用，以便拥有向受保护目录写入的权限。\n/etc/apt/sources.list.d/docker.list：将软件源条目写入到 /etc/apt/sources.list.d/ 目录下的一个新文件 docker.list 中。这是一种最佳实践，可以保持组织有序，并且更容易管理和删除单个软件的源。\n&gt; /dev/null：将 tee 命令输出到标准输出（屏幕） 的内容重定向到“空设备”，从而抑制任何输出，保持终端整洁。\n\n\n\n查看结果：\n\n2.8 更新软件包索引sudo apt update\n\n在添加了新的软件源（Docker 源）之后，必须再次运行 apt update，这样 APT 才会知道这个新源的存在，并从中获取可用软件包的列表。如果不执行这一步，系统将找不到 Docker 软件包。\n2.9 安装 Docker安装最新版本的 Docker，包括 Docker 引擎及其相关组件。\nsudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\ndocker-ce\n\n\n全称：Docker Community Edition\n作用：这是 Docker 引擎的核心，也就是常说的 “Docker 守护进程” (dockerd)。\n功能：它是一个持续运行的后台服务，负责管理 Docker 的方方面面：\n下载和存储镜像（Images）。\n创建、运行、停止和删除容器（Containers）。\n管理网络（Networks）和存储卷（Volumes）。\n暴露 REST API 供其他工具（如 CLI）调用。\n\n\n简言之：它是 Docker 的“大脑”和“发动机”。\n\n\ndocker-ce-cli\n\n\n全称：Docker Community Edition Command Line Interface\n作用：这是 Docker 的命令行工具。你平时在终端里打的 docker 命令就来自于它。\n功能：它本身不执行管理操作，而是作为一个客户端，接收你的命令（如 docker run, docker ps），然后通过 API 与上面的 docker-ce 守护进程通信，并告诉你结果。\n简言之：它是用户与 Docker 引擎交互的“遥控器”。\n\n\ncontainerd.io\n\n\n作用：这是一个行业标准的容器运行时。它是更底层、更核心的组件。\n功能：它负责容器生命周期的最底层操作，例如：\n从镜像中拉取和存储容器文件系统层。\n管理容器的执行、暂停、恢复和销毁。\n管理容器网络和存储的低级细节。\n\n\n与 Docker 的关系：从 Docker 的架构演变来看，docker-ce（守护进程）现在将大部分实际的容器运行时操作委托给了 containerd。这种解耦使得架构更清晰，containerd 也可以被其他系统（如 Kubernetes）直接使用。\n简言之：它是真正“动手”拉取镜像和运行容器的“工程师”，而 docker-ce 是它的“项目经理”。\n\n\ndocker-buildx-plugin\n\n\n作用：Docker 的扩展构建插件，提供了下一代强大的镜像构建功能。\n功能：它是 docker build 命令的增强版，支持许多高级特性：\n多平台构建：一次性为多种 CPU 架构（如 amd64, arm64, arm&#x2F;v7）构建镜像，无需复杂的交叉编译环境。\n构建缓存管理：更高效的缓存机制，加速构建过程。\n并行构建：等等。\n\n\n注意：在较新版本的 Docker 中，buildx 已成为默认的构建引擎。\n\n\ndocker-compose-plugin\n\n\n作用：Docker 官方提供的 Compose 功能，用于定义和运行多容器应用。\n功能：它提供了 docker compose 命令（注意没有横线），用来替代旧的、独立的 docker-compose（Python 编写）工具。\n通过一个 docker-compose.yml 文件来配置你的应用所需的所有服务、网络、卷。\n用一个命令（docker compose up）就能启动整个复杂的应用栈（例如一个包含 Web 前端、后端 API、数据库、缓存的应用）。\n\n\n为什么是插件形式：Docker 公司为了更好的集成和发布周期，将 Compose 功能做成了 CLI 插件，而不是一个独立的二进制文件。\n\ngraph LR    A[用户] --&gt; B[docker-ce-cli&lt;br&gt;CLI 命令行]    B -- 发送指令 --&gt; C[docker-ce&lt;br&gt;守护进程]    C -- 调度容器操作 --&gt; D[containerd.io&lt;br&gt;容器运行时]    D -- 真正运行容器 --&gt; E[Linux Kernel&lt;br&gt;系统内核]    F[docker-compose-plugin] -- 解析yml文件 --&gt; C    G[docker-buildx-plugin] -- 处理构建请求 --&gt; C\n\n\n2.10 验证安装是否成功docker -v\n\n \n2.11 开机自启安装成功后，Docker 服务将会开机自动启动。\n执行 systemctl is-enabled docker 命令，可以看到输出是 enabled，说明 Docker 已经设置为开机自动启动了\n \n三、替换国内镜像源3.1 拉取镜像失败当前 Docker 状态：\n \n现在已经安装好 Docker 了，但还不能完全使用。\n当前拉取镜像时，是从 Docker Hub 中拉取的。但国内访问 Docker Hub 时，会无法访问，导致无法拉取镜像。\n \n对于这种情况，建议添加国内镜像源地址。\n但请放心，国内镜像源本质上是为了提升访问速度而建立的 Docker Hub 缓存代理。它会帮你从 Docker Hub 拉取镜像，并将这些镜像存储在自己的服务器上。你通过它们下载的镜像，源头依然是 Docker Hub。你可以把它们理解为设立在身边的 Docker Hub “分身”，旨在解决远距离访问速度慢的问题。\n国内镜像源工作流程：\nflowchart TD    A[用户发起 docker pull 请求&lt;br&gt;例如: docker pull nginx] --&gt; B&#123;请求被拦截并转发&#125;    B --&gt; C[配置的国内镜像源&lt;br&gt;如 docker.xuanyuan.me]    subgraph C [镜像加速器 - Docker Hub 的缓存代理]        D&#123;检查镜像是否已缓存?&#125;        D -- 是 --&gt; E[直接从缓存返回镜像]        D -- 否 --&gt; F[向 Docker Hub 发起请求]        F --&gt; G[缓存镜像到本地]        G --&gt; H[返回镜像给用户]    end    E --&gt; I[用户获得镜像]    H --&gt; I    F -.-&gt; J[Docker Hub&lt;br&gt;hub.docker.com]\n\n\n\n3.2 打开配置文件当前 Docker 28.4.0 版本中，并没有存在配置文件，因此需要创建并打开。\nsudo vim /etc/docker/daemon.json\n\n\n\n3.3 添加镜像源当前一些可用的镜像源列表：\n\n\n\n镜像源名称\n镜像加速地址\n主要特点&#x2F;备注\n\n\n\nDaoCloud 镜像站\nhttps://docker.m.daocloud.io\n国内老牌服务商，稳定可靠\n\n\n网易云镜像加速\nhttp://hub-mirror.c.163.com\n多节点覆盖\n\n\n中国科学技术大学\nhttps://docker.mirrors.ustc.edu.cn\n教育网用户访问效果可能较好\n\n\n南京大学镜像站\nhttps://docker.nju.edu.cn\n支持 Docker Hub、GCR、GHCR、Quay、NVCR 等\n\n\nDocker 中国官方镜像\nhttps://registry.docker-cn.com\n官方认证，适合企业环境\n\n\n在配置时，我们一般会配置多个镜像源。\nDocker 会严格按照配置文件中列出的顺序来尝试镜像源，这时如果第一个源出现问题了，它会继续尝试第二个，以此类推。\n它不会自动选择“最快”的镜像源。因此建议将最稳定、最快、最可靠的镜像源放在第一位。\n具体配置如下：\n&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.m.daocloud.io&quot;,    &quot;http://hub-mirror.c.163.com&quot;,    &quot;https://docker.nju.edu.cn&quot;  ]&#125;\n\n \n注意：这些镜像源的设置不会影响 docker search 命令的搜索来源，docker search 默认依然是从 Docker Hub 的官方仓库查询。\n3.4 重启 Docker 服务重启 Docker 服务，实现镜像源更改。\nsudo systemctl restart docker\n\n如果修改了服务配置（例如，修改了 Docker 的 docker.service 文件中的环境变量、启动参数或依赖关系），systemd（Linux 的系统和服务管理器） 并不会自动感知到这个变化。\nsystemctl daemon-reload 命令会通知 systemd 去重新读取并加载所有服务单元文件的更改，使新的配置生效。\n当然，它只是让 systemd 记住了新的配置，只有下次启动服务时才会应用。\n我们当前修改的配置文件是 daemon.json，在重启服务前无需执行 sudo systemctl daemon-reload 这个命令。\n3.5 验证配置重启后，查看一下镜像源配置是否成功。可以看到相比最初，增加了 Registry Mirrors。\nsudo docker info\n\n \n3.6 测试现在我们可以正常拉取镜像并执行了，拉取（如果本地没有）hello-world 镜像，并创建一个新的容器来运行它，输出 “Hello from Docker!” 等信息，则表明成功。\nsudo docker container run hello-world\n\n \n四、添加当前用户到用户组4.1 权限说明默认情况下，只有 root 用户和组名为 docker 的用户组用户才能执行 Docker 命令。\n普通用户执行 Docker 命令时需要添加 sudo，如果觉得麻烦，可以将用户添加到 Docker 用户组。\n\nDocker 守护进程（dockerd）启动后，会创建一个用于通信的 Unix 套接字（Socket）文件，默认路径是 /var/run/docker.sock。\n通过命令可以查看到这个文件的详细信息：\nlanyu@server:~$ ls -l /var/run/docker.socksrw-rw---- 1 root docker 0 Sep 15 09:37 /var/run/docker.sock\n\n这里的关键信息是：\n\n所有者 (Owner): root\n所属组 (Group): docker\n权限 (Permissions): srw-rw----（其中的 rw- 表示所属组具有读写权限）\n\n这意味着：\n\nroot 用户 永远可以直接操作这个套接字（所以用 sudo 总能运行 Docker 命令）。\n所有属于 docker 组 的用户也具有读写权限，因此可以无需 sudo 直接与 Docker 守护进程通信。\n其他用户则没有任何权限。\n\n虽然可以通过修改配置文件 daemon.json 的方式，修改默认组名，但不推荐。\n\n4.2 查看用户组默认情况下，安装好 Docker 后，会自动创建一个用户组，通过以下命令可以查看 docker 组 信息。\ngrep docker /etc/group\n\n \n/etc/group 文件存储了系统中所有用户组（Group） 的定义信息，其中的每一行都代表一个用户组，其格式由冒号 : 分隔为四个字段。\n\n\n\n示例值\n含义\n\n\n\ndocker\n用户组的名称。这就是你查询的组。\n\n\nx\n经过加密的组密码。几乎总是显示为 x，表示密码实际上被存储在更安全的 /etc/gshadow 文件中。通常组密码很少使用。\n\n\n988\n组ID (GID)。这是系统用来识别这个组的唯一数字。这个数字在不同系统上可能不同（常见的有 999, 998 等），988 是完全正常的。\n\n\n(空)\n属于该组的用户成员列表。这个字段是空的，表示目前没有用户被直接添加为这个组的成员。\n\n\n如果没有任何返回，那么可以执行 sudo groupadd docker 命令去创建一个名为 docker 的用户组。\n4.3 添加当前用户sudo usermod -aG docker $USER\n\n\nusermod：修改用户属性的命令\n-aG：追加到附加组 (Append to Supplementary Groups)\ndocker：目标用户组的名称\n$USER：shell 环境变量，代表当前用户名\n\n完成后，再次查看用户组，可以看到当前用户已经添加成功。\n \n4.4 切换到 docker 组newgrp docker\n\nnewgrp 命令的主要目的是临时性地将当前用户会话（terminal session）的主要组（primary group）或附加组（supplementary group）的权限生效。\n当前用户已经添加到 docker 组，这个更改虽然被写入了 /etc/group 文件，但不会自动应用到你已经登录的当前会话中。\n要让新的组权限生效，有三种方式：\n\n注销后重新登录（最彻底的方式）。\n打开一个新的终端窗口（新的会话会读取新的组信息）。\n使用 newgrp 命令（如果执行 exit 命令会退回到当前用户之前的权限）。\n\n我们使用 FinalShell 连接，其实打开一个新的终端窗口更方便。\n4.5 测试执行一个 Docker 命令不加 sudo ，比如 docker images，可以看到命令正常运行。\n \n","categories":["云原生与分布式架构"],"tags":["Docker","安装"]}]